<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Simulator</title>
    <style>
        body, html {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: 'Courier New', monospace;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
        }

        .infoDisplay {
            position: absolute;
            color: white;
            background: rgba(0, 0, 0, 1);
            padding: 5px;
        }

        #fpsCounter {
            top: 10px;
            right: 10px;
        }

        #coordinateDisplay {
            top: 10px;
            left: 10px;
        }
    </style>
</head>
<body>
<canvas id="renderCanvas"></canvas>
<div id="coordinateDisplay" class="infoDisplay"></div>
<div id="fpsCounter" class="infoDisplay"></div>
<script type="module">
    import {pipeline, env} from 'https://cdn.jsdelivr.net/npm/@xenova/transformers@2.10.1';

    env.allowLocalModels = false;
</script>
<script src="https://cdn.babylonjs.com/babylon.js"></script>
<script src="https://cdn.babylonjs.com/cannon.js"></script>
<script>
    // BEGIN INFERENCE
    async function runTextGeneration() {
        const classifier = await pipeline('text-generation', '', {});
        const result = await classifier(text, {
            max_new_tokens: 32,
            do_sample: true,
            top_k: 50,
            top_p: 0.95,
            num_return_sequences: 1
        });

        console.log(result[0].generated_text);
        classifier.dispose();
    }

    // END INFERENCE

    var box, scene, engine, canvas;
    var enableRandomMovement = true;
    var lastMoveTime = 0;
    var moveInterval = 2000;
    var movementSpeed = 5;

    function createScene() {
        scene = new BABYLON.Scene(engine);
        scene.enablePhysics(new BABYLON.Vector3(0, -9.81, 0), new BABYLON.CannonJSPlugin());

        var camera = new BABYLON.ArcRotateCamera("Camera", Math.PI / 2, Math.PI / 2, 2, new BABYLON.Vector3(0, 0, 5), scene);
        camera.attachControl(canvas, true);

        var light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(1, 1, 0), scene);

        box = BABYLON.MeshBuilder.CreateBox("box", {size: 1}, scene);
        box.position.y = 1;
        var boxMaterial = new BABYLON.StandardMaterial("boxMat", scene);
        boxMaterial.diffuseColor = new BABYLON.Color3(0.345, 0.396, 0.949);
        box.material = boxMaterial;
        box.physicsImpostor = new BABYLON.PhysicsImpostor(box, BABYLON.PhysicsImpostor.BoxImpostor, {
            mass: 1,
            restitution: 0.1
        }, scene);

        var wallAndFloorMaterial = new BABYLON.StandardMaterial("wallFloorMat", scene);
        wallAndFloorMaterial.diffuseColor = new BABYLON.Color3.FromHexString("#f0f2ff");

        createWalls();
    }

    function createWalls() {
        var wallHeight = 1, wallDepth = 2;
        createWall(new BABYLON.Vector3(0, wallHeight / 2, -10), {height: wallHeight, width: 20, depth: wallDepth});
        createWall(new BABYLON.Vector3(0, wallHeight / 2, 10), {height: wallHeight, width: 20, depth: wallDepth});
        createWall(new BABYLON.Vector3(-10, wallHeight / 2, 0), {height: wallHeight, width: wallDepth, depth: 20});
        createWall(new BABYLON.Vector3(10, wallHeight / 2, 0), {height: wallHeight, width: wallDepth, depth: 20});
        createWall(new BABYLON.Vector3(0, -wallDepth / 2, 0), {height: wallDepth, width: 20, depth: 20});
    }

    function createWall(position, size) {
        var wall = BABYLON.MeshBuilder.CreateBox("wall", size, scene);
        wall.position = position;
        wall.physicsImpostor = new BABYLON.PhysicsImpostor(wall, BABYLON.PhysicsImpostor.BoxImpostor, {
            mass: 0,
            restitution: 0.9
        }, scene);
    }

    function updateCoordinates() {
        var coords = "X: " + box.position.x.toFixed(2) + ", Y: " + box.position.y.toFixed(2) + ", Z: " + box.position.z.toFixed(2);
        document.getElementById('coordinateDisplay').innerText = coords;
    }

    function moveCube(angle) {
        var forceMagnitude = movementSpeed;
        var forceDirection = new BABYLON.Vector3(Math.sin(angle), 0, Math.cos(angle));
        forceDirection.normalize();
        forceDirection.scaleInPlace(forceMagnitude);

        box.physicsImpostor.applyImpulse(forceDirection, box.getAbsolutePosition());
    }

    function randomMovement() {
        if (!enableRandomMovement) return;
        var currentTime = new Date().getTime();
        if (currentTime - lastMoveTime > moveInterval) {
            var angles = [0, Math.PI / 2, Math.PI, -Math.PI / 2];
            var randomAngle = angles[Math.floor(Math.random() * angles.length)];
            moveCube(randomAngle);
            lastMoveTime = currentTime;
        }
    }

    function initializeEventListeners() {
        window.addEventListener('keydown', function (event) {
            var moveAngle = 0;
            switch (event.key) {
                case 'w':
                case 'W':
                    moveAngle = -Math.PI / 2;
                    break;
                case 's':
                case 'S':
                    moveAngle = Math.PI / 2;
                    break;
                case 'a':
                case 'A':
                    moveAngle = Math.PI;
                    break;
                case 'd':
                case 'D':
                    moveAngle = 0;
                    break;
                default:
                    return;
            }
            moveCube(moveAngle);
        });

        window.addEventListener('resize', function () {
            engine.resize();
        });
    }

    function initialize() {
        canvas = document.getElementById('renderCanvas');
        engine = new BABYLON.Engine(canvas, true);

        createScene();

        let fpsDisplayUpdateInterval = 1000;
        let lastFpsUpdateTime = 0;
        let tabIsActive = true;

        engine.runRenderLoop(function () {
            if (tabIsActive) {
                scene.render();
                updateCoordinates();

                let currentTime = Date.now();
                if (currentTime - lastFpsUpdateTime > fpsDisplayUpdateInterval) {
                    document.getElementById('fpsCounter').innerHTML = engine.getFps().toFixed(0) + ' fps';
                    lastFpsUpdateTime = currentTime;
                }
            }
        });

        initializeEventListeners();
        setInterval(randomMovement, 200);

        document.addEventListener('visibilitychange', function () {
            if (document.visibilityState === 'visible') {
                tabIsActive = true;
            } else {
                tabIsActive = false;
            }
        });
    }

    window.addEventListener('DOMContentLoaded', initialize);

</script>
</body>
</html>