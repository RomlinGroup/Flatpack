<!DOCTYPE html>
<html>
<head>
    <title>Simulator</title>
    <style>
        body {
            margin: 0;
        }

        canvas {
            display: block;
        }

        #demoStatus {
            position: fixed;
            top: 10px;
            left: 10px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 5px;
            font-family: Arial, sans-serif;
            font-size: 14px;
            color: #333
        }

        #keyGuide {
            position: fixed;
            bottom: 10px;
            right: 10px;
            padding: 10px;
            background: rgba(0, 0, 0, 1);
            border-radius: 5px;
            font-family: Arial, sans-serif;
            font-size: 14px;
            color: #ffffff;
        }
    </style>
</head>

<body>

<div id="demoStatus">
    Demo Mode: OFF
</div>


<!-- Controls Guide -->
<div id="keyGuide">
    <strong>Controls:</strong><br>
    Base - Q/E<br>
    Upper Arm - W/S<br>
    Forearm - R/F<br>
    Open Pincers - O<br>
    Close Pincers - P<br>
    Rotate Pincers - T/Y<br>
    Toggle Demo Mode - D
</div>

<!-- Three.js and OrbitControls Scripts -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

<!-- Main Script for Robot Arm Simulation -->
<script>
    // Constants and Configuration
    const ARM_COLORS = {
        base: 0xff0000,
        shoulder: 0x00ff00,
        upperArm: 0x00ff00,
        forearm: 0x0000ff
    };

    // Scene Objects
    let scene, camera, renderer, controls;
    let base, shoulder, upperArm, elbow, forearm;
    let pincerClosing = true;
    let pincerAngle = 0;
    const pincerSpeed = 0.005;
    const maxPincerAngle = Math.PI / 5;
    let pincerClaw1, pincerClaw2;
    let demoMode = false;
    const demoSpeed = 0.01;
    let forearmRotation = 0;
    let fullCycleCount = 0;
    const maxCycles = 1;
    let cylinderDot;

    // Initialize Scene, Camera, and Renderer
    function init() {
        setupScene();
        setupCamera();
        setupRenderer();
        addLighting();
        addRobotArm();
        addFloor();
        setupControls();
        animate();
    }

    // Setup the Three.js Scene
    function setupScene() {
        scene = new THREE.Scene();
    }

    // Setup the Camera
    function setupCamera() {
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(2, 1, 2);
    }

    // Setup the Renderer
    function setupRenderer() {
        renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
    }

    // Add Lighting to the Scene
    function addLighting() {
        // Directional Light
        const light = new THREE.DirectionalLight(0xffffff, 1);
        light.position.set(0, 1, 1).normalize();
        scene.add(light);

        // Ambient Light
        const ambientLight = new THREE.AmbientLight(0x404040); // Color of the ambient light
        scene.add(ambientLight);
    }

    // Add Robot Arm Components to the Scene
    function addRobotArm() {
        base = createSegment(0.5, 0.6, 0.3, ARM_COLORS.base, 0.15);
        shoulder = createSegment(0, 0, 0.3, ARM_COLORS.shoulder, 0.15);
        upperArm = createSegment(0.15, 0.15, 1.2, ARM_COLORS.upperArm, 0.6);

        // Create the green elbow joint sphere
        const elbowGeometry = new THREE.SphereGeometry(0.15, 32, 32);
        const elbowMaterial = new THREE.MeshStandardMaterial({
            color: 0x00ff00
        });
        elbow = new THREE.Mesh(elbowGeometry, elbowMaterial);
        elbow.position.y = 0.6; // Adjust the position as needed

        forearm = createSegment(0.1, 0.1, 1.0, ARM_COLORS.forearm, 0.5);

        scene.add(base);
        base.add(shoulder);
        shoulder.add(upperArm);
        upperArm.add(elbow); // Add the elbow joint to the upper arm
        elbow.add(forearm);

        // Set the initial rotation of the shoulder to the maximum downward angle within the constraints
        shoulder.rotation.x = THREE.MathUtils.degToRad(-30); // Convert -65 degrees to radians

        // Set the initial rotation of the elbow to the maximum downward angle within the constraints
        elbow.rotation.x = THREE.MathUtils.degToRad(-90); // Convert -90 degrees to radians

        // Create Pincers
        const pincerMaterial = new THREE.MeshStandardMaterial({
            color: 0xffff00
        }); // Yellow color for pincers
        const pincerBaseGeometry = new THREE.BoxGeometry(0.1, 0.05, 0.05);
        const pincerBase1 = new THREE.Mesh(pincerBaseGeometry, pincerMaterial);
        const pincerBase2 = new THREE.Mesh(pincerBaseGeometry, pincerMaterial);
        const pincerClawGeometry = new THREE.BoxGeometry(0.1, 0.01, 0.1);
        pincerClaw1 = new THREE.Mesh(pincerClawGeometry, pincerMaterial);
        pincerClaw2 = new THREE.Mesh(pincerClawGeometry, pincerMaterial);

        pincerBase1.position.set(0.05, 0.5, 0);
        pincerBase2.position.set(-0.05, 0.5, 0);
        pincerBase1.rotation.x = Math.PI / 2;
        pincerBase2.rotation.x = Math.PI / 2;
        pincerBase1.rotation.z = 55;
        pincerBase2.rotation.z = -55;
        forearm.add(pincerBase1);
        forearm.add(pincerBase2);

        pincerClaw1.position.set(0, 0.02, -0.05);
        pincerClaw2.position.set(0, 0.02, -0.05);
        pincerClaw1.rotation.x = 0;
        pincerClaw2.rotation.x = 0;
        pincerClaw1.rotation.z = 0;
        pincerClaw2.rotation.z = 0;
        pincerBase1.add(pincerClaw1);
        pincerBase2.add(pincerClaw2);

        const dotGeometry = new THREE.SphereGeometry(0.05, 32, 32);
        const dotMaterial = new THREE.MeshBasicMaterial({color: 0xff0000});
        sphereDot = new THREE.Mesh(dotGeometry, dotMaterial);
        sphereDot.position.set(0, forearm.geometry.parameters.height / 2 + 0.1, 0);
        forearm.add(sphereDot);
    }

    // Create a Segment of the Robot Arm
    function createSegment(topRadius, bottomRadius, height, color, yPos) {
        var geometry, segment;

        if (topRadius === 0 && bottomRadius === 0) {
            // Create a sphere geometry since the top and bottom radius are 0
            geometry = new THREE.SphereGeometry(height, 32, 32); // height is used as the sphere radius
            var material = new THREE.MeshStandardMaterial({
                color: color
            });
            segment = new THREE.Mesh(geometry, material);
        } else {
            // Create a cylinder geometry
            geometry = new THREE.CylinderGeometry(topRadius, bottomRadius, height, 32);
            var material = new THREE.MeshStandardMaterial({
                color: color
            });
            segment = new THREE.Mesh(geometry, material);
        }

        segment.position.y = yPos;
        return segment;
    }

    // Add Floor to the Scene with Grey Background and Black Grid Pattern
    function addFloor() {
        // Create a grey background plane
        const backgroundGeometry = new THREE.PlaneGeometry(10, 10);
        const backgroundMaterial = new THREE.MeshStandardMaterial({
            color: 0xffffff,
            side: THREE.DoubleSide,
        });
        const background = new THREE.Mesh(backgroundGeometry, backgroundMaterial);
        background.rotation.x = -Math.PI / 2;
        background.position.y = -0.01;
        scene.add(background);

        // Create a black grid pattern on top of the background
        const gridGeometry = new THREE.PlaneGeometry(10, 10, 10, 10);
        const gridMaterial = new THREE.MeshBasicMaterial({
            color: 0x000000,
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.5,
            wireframe: true,
        });
        const grid = new THREE.Mesh(gridGeometry, gridMaterial);
        grid.rotation.x = -Math.PI / 2;
        grid.position.y = 0.001; // Slightly above the grey background
        scene.add(grid);
    }

    // Setup Controls for the Scene
    function setupControls() {
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.target.set(0, 1, 0);
        controls.update();
        document.addEventListener("keydown", onDocumentKeyDown, false);
    }

    function animate() {
        requestAnimationFrame(animate);

        if (demoMode) {
            automatedMovements();
        }

        renderer.render(scene, camera); // Render the main scene
    }

    // Clamp Rotation Function
    function clampRotation(currentRotation, minAngle, maxAngle) {
        const minRadians = THREE.MathUtils.degToRad(minAngle);
        const maxRadians = THREE.MathUtils.degToRad(maxAngle);
        return Math.max(minRadians, Math.min(maxRadians, currentRotation));
    }

    // Function to open the pincers (straight out)
    function openPincers() {
        pincerClaw1.position.set(0, 0.02, -0.05);
        pincerClaw2.position.set(0, 0.02, -0.05);
    }

    // Function to close the pincers (reset to default position)
    function closePincers() {
        pincerClaw1.position.set(0, -0.02, -0.05);
        pincerClaw2.position.set(0, -0.02, -0.05);
    }

    // Variables to track movement state
    let movementStep = 0;
    let isPincerOpen = false;

    function automatedMovements() {
        switch (movementStep) {
            case 0:
                // Rotate base
                rotateBase(1);
                fullCycleCount += demoSpeed;
                if (fullCycleCount >= 2 * Math.PI) { // Full rotation
                    fullCycleCount = 0; // Reset the cycle count
                    movementStep++;
                }
                movementStep = 0;
                break;
        }
    }

    // Movement functions
    function rotateBase(direction) {
        const delta = (demoMode ? demoSpeed : 0.05) * direction;
        base.rotation.y += delta;
    }

    function moveShoulder(direction) {
        const delta = (demoMode ? demoSpeed : 0.05) * direction;
        shoulder.rotation.x += delta;
        shoulder.rotation.x = clampRotation(shoulder.rotation.x, -55, 0);
    }

    function moveElbow(direction) {
        const delta = (demoMode ? demoSpeed : 0.05) * direction;
        elbow.rotation.x += delta;
        elbow.rotation.x = clampRotation(elbow.rotation.x, -90, 0);
    }

    function rotateForearm(direction) {
        const rotationSpeed = demoMode ? demoSpeed : 0.1; // Respect demo speed
        forearmRotation += direction * rotationSpeed;
        forearm.rotation.y = forearmRotation;
    }

    // Handle Keyboard Inputs
    function onDocumentKeyDown(event) {
        var keyCode = event.which;

        if (!demoMode) {
            if (keyCode == 81) {
                rotateBase(-1);
            } // Q
            else if (keyCode == 69) {
                rotateBase(1);
            } // E
            else if (keyCode == 87) {
                moveShoulder(1);
            } // W
            else if (keyCode == 83) {
                moveShoulder(-1);
            } // S
            else if (keyCode == 82) {
                moveElbow(1);
            } // R
            else if (keyCode == 70) {
                moveElbow(-1);
            } // F
            else if (keyCode == 79) {
                openPincers();
            } // O
            else if (keyCode == 80) {
                closePincers();
            } // P
            else if (keyCode == 84) {
                rotateForearm(1);
            } // T
            else if (keyCode == 89) {
                rotateForearm(-1);
            } // Y
        }

        if (keyCode == 68) {
            demoMode = !demoMode;
            document.getElementById("demoStatus").innerText = "Demo Mode: " + (demoMode ? "ON" : "OFF");
        } // D
    }

    init();
</script>
</body>
</html>