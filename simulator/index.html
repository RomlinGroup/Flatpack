<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Simulator</title>
    <style>
        body, html {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: 'Courier New', monospace;
            font-size: 20px;
        }

        #renderCanvas {
            background: #000;
            width: 100%;
            height: 100%;
        }

        .infoDisplay {
            position: absolute;
            color: white;
            background: rgba(0, 0, 0, 1);
            padding: 5px;
        }

        #fpsCounter {
            top: 10px;
            right: 10px;
        }

        #coordinateDisplay {
            top: 10px;
            left: 10px;
        }

        #countdownTimer {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            background: rgba(0, 0, 0, 1);
            padding: 5px;
        }

        #successCount, #failCount {
            position: absolute;
            bottom: 10px;
            color: white;
            background: rgba(0, 0, 0, 1);
            padding: 5px;
        }

        #successCount {
            left: 10px;
        }

        #failCount {
            right: 10px;
        }
    </style>
</head>
<body>
<canvas id="renderCanvas"></canvas>
<div id="coordinateDisplay" class="infoDisplay"></div>
<div id="fpsCounter" class="infoDisplay"></div>
<div id="countdownTimer" class="infoDisplay"></div>
<div id="successCount" class="infoDisplay">Success: 0</div>
<div id="failCount" class="infoDisplay">Fail: 0</div>
<script src="https://cdn.babylonjs.com/babylon.js"></script>
<script src="https://cdn.babylonjs.com/cannon.js"></script>
<script>
    var canvas;
    var collisionCount = 0;
    var countdown;
    var countdownIntervalId;
    var enableRandomMovement = false;
    var executeRandomMovement = true;
    var engine;
    var failCount = 0;
    var lastMoveTime = 0;
    var moveInterval = 500;
    var movementSpeed = 50;
    var pauseTime = 0;
    var scene;
    var simulationTimeoutId;
    var sphere;
    var successCount = 0;
    var targetCircle;
    var targetReached = false;

    function createScene() {
        scene = new BABYLON.Scene(engine);
        scene.enablePhysics(new BABYLON.Vector3(0, -9.81, 0), new BABYLON.CannonJSPlugin());
        scene.clearColor = new BABYLON.Color3(0.75, 0.75, 0.75);

        var camera = new BABYLON.FreeCamera("Camera", new BABYLON.Vector3(0, 30, 0), scene);
        camera.setTarget(BABYLON.Vector3.Zero());
        camera.rotation.x = Math.PI / 2;

        var light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(1, 1, 0), scene);

        sphere = BABYLON.MeshBuilder.CreateSphere("sphere", {diameter: 2}, scene);
        sphere.position = new BABYLON.Vector3(0, 1, 5);
        var sphereMaterial = new BABYLON.StandardMaterial("sphereMat", scene);
        sphereMaterial.diffuseColor = new BABYLON.Color3(0.75, 0.75, 0.75);
        sphereMaterial.specularColor = new BABYLON.Color3(1, 1, 1);
        sphereMaterial.ambientColor = new BABYLON.Color3(0.75, 0.75, 0.75);
        sphere.material = sphereMaterial;
        sphere.physicsImpostor = new BABYLON.PhysicsImpostor(sphere, BABYLON.PhysicsImpostor.SphereImpostor, {
            mass: 10,
            restitution: 0.5
        }, scene);
        sphere.physicsImpostor.registerOnPhysicsCollide(scene.meshes, function (main, collided) {
            if (collided.object.isWall) {
                collisionCount++;
                if (collisionCount > 1) {
                    randomOrTargetedMovement();
                    collisionCount = 0;
                }
            }
        });

        targetCircle = BABYLON.MeshBuilder.CreateDisc("target", {radius: 1, tessellation: 0}, scene);
        targetCircle.position.y = 0.1;
        targetCircle.position.x = 0;
        targetCircle.position.z = -5;
        targetCircle.rotation.x = Math.PI / 2;
        var targetMaterial = new BABYLON.StandardMaterial("targetMat", scene);
        targetMaterial.diffuseColor = new BABYLON.Color3(0, 0, 0);
        targetCircle.material = targetMaterial;

        createWalls();
    }

    function createWalls() {
        const wallHeight = 1;

        const wallConfigs = [
            {position: new BABYLON.Vector3(0, wallHeight / 2, -10), size: {height: wallHeight, width: 20, depth: 1}},
            {position: new BABYLON.Vector3(0, wallHeight / 2, 10), size: {height: wallHeight, width: 20, depth: 1}},
            {position: new BABYLON.Vector3(-10, wallHeight / 2, 0), size: {height: wallHeight, width: 1, depth: 20}},
            {position: new BABYLON.Vector3(10, wallHeight / 2, 0), size: {height: wallHeight, width: 1, depth: 20}},
            {position: new BABYLON.Vector3(0, -0.5, 0), size: {height: 1, width: 20, depth: 20}},
            {position: new BABYLON.Vector3(0, 0.5, 0), size: {height: 1, width: 5, depth: 1}}
        ];

        wallConfigs.forEach(config => createWall(config.position, config.size));
    }

    function createWall(position, size) {
        var wall = BABYLON.MeshBuilder.CreateBox("wall", size, scene);
        wall.position = position;
        wall.physicsImpostor = new BABYLON.PhysicsImpostor(wall, BABYLON.PhysicsImpostor.BoxImpostor, {
            mass: 100,
            restitution: 0.9
        }, scene);

        if (position.equals(new BABYLON.Vector3(0, 0.5, 0))) {
            var specialWallMaterial = new BABYLON.StandardMaterial("specialWallMat", scene);
            specialWallMaterial.diffuseColor = new BABYLON.Color3(0.75, 0.75, 0.75);
            wall.material = specialWallMaterial;
        } else {
        }

        wall.isWall = true;
    }

    function updateCoordinates() {
        var coords = `X: ${sphere.position.x.toFixed(0)}, Y: ${sphere.position.y.toFixed(0)}, Z: ${sphere.position.z.toFixed(0)}`;
        document.getElementById('coordinateDisplay').innerText = coords;

        checkIfInsideTarget();
    }

    function startSimulationTimeout() {
        countdown = 10;
        updateCountdownDisplay();
        clearTimeout(simulationTimeoutId);
        simulationTimeoutId = setInterval(function () {
            countdown -= 1;
            updateCountdownDisplay();

            if (countdown <= 0) {
                //console.log("Simulation timed out! Resetting...");
                clearInterval(simulationTimeoutId);
                failCount++;
                updateScoreDisplay();
                resetSimulation();
            }
        }, 1000);

    }

    function updateScoreDisplay() {
        document.getElementById('successCount').innerText = 'Success: ' + successCount;
        document.getElementById('failCount').innerText = 'Fail: ' + failCount;
    }

    function updateCountdownDisplay() {
        document.getElementById('countdownTimer').innerText = countdown.toString();
    }

    function checkIfInsideTarget() {
        var distance = BABYLON.Vector3.Distance(sphere.position, targetCircle.position);
        if (distance < 1 && !targetReached) {
            targetReached = true;
            enableRandomMovement = false;
            clearTimeout(simulationTimeoutId);
            successCount++;
            updateScoreDisplay();

            sphere.position.x = targetCircle.position.x;
            sphere.position.z = targetCircle.position.z;

            sphere.isVisible = false;

            freezeBall();

            setTimeout(resetSimulation, 1000);
        }
    }

    function freezeBall() {
        if (sphere.physicsImpostor) {
            sphere.physicsImpostor.setLinearVelocity(BABYLON.Vector3.Zero());
            sphere.physicsImpostor.setAngularVelocity(BABYLON.Vector3.Zero());
        }
    }

    var movements = {
        'w': new BABYLON.Vector3(0, 0, -1),
        'a': new BABYLON.Vector3(1, 0, 0),
        's': new BABYLON.Vector3(0, 0, 1),
        'd': new BABYLON.Vector3(-1, 0, 0),
        'wa': new BABYLON.Vector3(1, 0, -1),
        'wd': new BABYLON.Vector3(-1, 0, -1),
        'sa': new BABYLON.Vector3(1, 0, 1),
        'sd': new BABYLON.Vector3(-1, 0, 1)
    };

    function moveSphere(direction) {
        var forceDirection = direction.clone().normalize().scale(movementSpeed);
        sphere.physicsImpostor.applyImpulse(forceDirection, sphere.getAbsolutePosition());
    }

    function reapplyWallPhysics() {
        scene.meshes.forEach(mesh => {
            if (mesh.name === "wall") {
                mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.BoxImpostor, {
                    mass: 0,
                    restitution: 0.9
                }, scene);
            }
        });
    }

    function resetSimulation() {
        //console.log("Resetting simulation");
        targetReached = false;

        sphere.position = new BABYLON.Vector3(0, 1, 5);

        if (sphere.physicsImpostor) {
            sphere.physicsImpostor.setLinearVelocity(BABYLON.Vector3.Zero());
            sphere.physicsImpostor.setAngularVelocity(BABYLON.Vector3.Zero());
        }

        scene.meshes.forEach(mesh => {
            if (mesh.name.startsWith("wall")) {
                mesh.physicsImpostor.dispose();
                mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.BoxImpostor, {
                    mass: 0,
                    restitution: 0.9
                }, scene);
            }
        });

        sphere.isVisible = true;
        enableRandomMovement = false;
        startSimulationTimeout();
    }

    function findClearPath(currentDirection) {
        // Check several directions around the current direction
        var testDirections = [
            currentDirection,
            rotateDirection(currentDirection, Math.PI / 4),
            rotateDirection(currentDirection, -Math.PI / 4)
        ];

        var bestDirection = currentDirection;
        var longestClearPath = 0;

        testDirections.forEach(function (dir) {
            var rayLength = measureClearPathLength(dir);
            if (rayLength > longestClearPath) {
                longestClearPath = rayLength;
                bestDirection = dir;
            }
        });

        return bestDirection;
    }

    function measureClearPathLength(direction) {
        var ray = new BABYLON.Ray(sphere.position, direction, 10);
        var hit = scene.pickWithRay(ray);

        if (hit.pickedMesh && hit.pickedMesh.isWall) {
            return BABYLON.Vector3.Distance(sphere.position, hit.pickedPoint);
        }
        return 10;
    }

    function moveToTarget() {
        if (!targetReached) {
            var targetDirection = targetCircle.position.subtract(sphere.position).normalize();
            var closestKey = getClosestDirectionKey(targetDirection);
            console.log(closestKey);
            moveSphere(movements[closestKey]);
        }
    }

    function getClosestDirectionKey(targetDirection) {
        var closestKey = '';
        var closestDot = -Infinity;

        Object.keys(movements).forEach(function (key) {
            var direction = movements[key].normalize();
            var dotProduct = BABYLON.Vector3.Dot(direction, targetDirection);

            if (dotProduct > closestDot) {
                closestDot = dotProduct;
                closestKey = key;
            }
        });

        return closestKey;
    }

    function randomOrTargetedMovement() {
        if (!executeRandomMovement) {
            return;
        }

        var currentTime = new Date().getTime();
        if (currentTime - lastMoveTime > moveInterval) {
            if (Math.random() < 0.5) {
                moveToTarget();
            } else {
                var keys = Object.keys(movements);
                var randomKey = keys[Math.floor(Math.random() * keys.length)];
                console.log(randomKey);
                moveSphere(movements[randomKey]);
            }
            lastMoveTime = currentTime;
        }
    }

    function startSimulationTimeout(remainingTime = 10) {
        countdown = remainingTime;
        updateCountdownDisplay();
        clearInterval(countdownIntervalId);
        countdownIntervalId = setInterval(updateCountdown, 1000);
    }

    function updateCountdown() {
        countdown -= 1;
        updateCountdownDisplay();
        if (countdown <= 0) {
            clearInterval(countdownIntervalId);
            failCount++;
            updateScoreDisplay();
            resetSimulation();
        }
    }

    function pauseSimulationTimeout() {
        clearInterval(countdownIntervalId);
        pauseTime = countdown; // Save remaining time
    }

    function resumeSimulationTimeout() {
        startSimulationTimeout(pauseTime); // Resume with remaining time
    }

    function initialize() {
        canvas = document.getElementById('renderCanvas');
        engine = new BABYLON.Engine(canvas, true);

        createScene();

        let fpsDisplayUpdateInterval = 1000, lastFpsUpdateTime = 0, lastRenderTime = Date.now();

        engine.runRenderLoop(function () {
            let now = Date.now(), deltaTime = now - lastRenderTime;
            lastRenderTime = now;

            if (document.visibilityState === 'visible') {
                scene.render();
                updateCoordinates();
                if (now - lastFpsUpdateTime > fpsDisplayUpdateInterval) {
                    document.getElementById('fpsCounter').innerText = `${engine.getFps().toFixed(0)} fps`;
                    lastFpsUpdateTime = now;
                }
            }
        });

        window.addEventListener('resize', () => engine.resize());

        setInterval(randomOrTargetedMovement, 200);

        document.addEventListener('visibilitychange', function () {
            if (document.visibilityState === 'hidden') {
                engine.stopRenderLoop();
                scene.physicsEnabled = false;
                pauseSimulationTimeout();
                executeRandomMovement = false;
            } else {
                lastRenderTime = Date.now();
                scene.physicsEnabled = true;
                engine.runRenderLoop(function () {
                    let now = Date.now(), deltaTime = now - lastRenderTime;
                    lastRenderTime = now;

                    scene.render();
                    updateCoordinates();
                    if (now - lastFpsUpdateTime > fpsDisplayUpdateInterval) {
                        document.getElementById('fpsCounter').innerText = `${engine.getFps().toFixed(0)} fps`;
                        lastFpsUpdateTime = now;
                    }
                });

                resumeSimulationTimeout();
                executeRandomMovement = true;
            }
        });

    }

    window.addEventListener('DOMContentLoaded', function () {
        initialize();
        resetSimulation();
        updateScoreDisplay();
    });

    startSimulationTimeout();
</script>
</body>
</html>