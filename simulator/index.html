<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Simulator</title>
    <style>
        body, html {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: 'Courier New', monospace;
            font-size: 20px;
        }

        #renderCanvas {
            background: #000;
            width: 100%;
            height: 100%;
        }

        .infoDisplay {
            position: absolute;
            color: white;
            background: rgba(0, 0, 0, 0.75);
            padding: 5px;
        }

        #fpsCounter {
            top: 10px;
            right: 10px;
        }

        #coordinateDisplay {
            top: 10px;
            left: 10px;
        }

        #countdownTimer {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            background: rgba(0, 0, 0, 0.75);
            padding: 5px;
        }

        #successCount, #failCount {
            position: absolute;
            bottom: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.75);
            padding: 5px;
        }

        #successCount {
            left: 10px;
        }

        #failCount {
            right: 10px;
        }
    </style>
</head>
<body>
<canvas id="renderCanvas"></canvas>
<div id="coordinateDisplay" class="infoDisplay"></div>
<div id="fpsCounter" class="infoDisplay"></div>
<div id="countdownTimer" class="infoDisplay"></div>
<div id="successCount" class="infoDisplay">Success: 0</div>
<div id="failCount" class="infoDisplay">Fail: 0</div>
<script src="https://cdn.babylonjs.com/babylon.js"></script>
<script src="https://cdn.babylonjs.com/cannon.js"></script>
<script>
    var canvas;
    var enableRandomMovement = false;
    var engine;
    var failCount = 0;
    var lastMoveTime = 0;
    var moveInterval = 1000;
    var movementSpeed = 10;
    var scene;
    var simulationTimeoutId;
    var sphere;
    var successCount = 0;
    var targetCircle;
    var targetReached = false;

    function createScene() {
        scene = new BABYLON.Scene(engine);
        scene.enablePhysics(new BABYLON.Vector3(0, -9.81, 0), new BABYLON.CannonJSPlugin());
        scene.clearColor = new BABYLON.Color3(0.75, 0.75, 0.75);

        var camera = new BABYLON.FreeCamera("Camera", new BABYLON.Vector3(0, 40, 0), scene);
        camera.setTarget(BABYLON.Vector3.Zero());
        camera.rotation.x = Math.PI / 2;

        var light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(1, 1, 0), scene);

        sphere = BABYLON.MeshBuilder.CreateSphere("sphere", {diameter: 1}, scene);
        sphere.position = new BABYLON.Vector3(0, 1, 8);
        var sphereMaterial = new BABYLON.StandardMaterial("sphereMat", scene);
        sphereMaterial.diffuseColor = new BABYLON.Color3(0.75, 0.75, 0.75);
        sphereMaterial.specularColor = new BABYLON.Color3(1, 1, 1);
        sphereMaterial.ambientColor = new BABYLON.Color3(0.75, 0.75, 0.75);
        sphere.material = sphereMaterial;
        sphere.physicsImpostor = new BABYLON.PhysicsImpostor(sphere, BABYLON.PhysicsImpostor.SphereImpostor, {
            mass: 1,
            restitution: 0.5
        }, scene);

        targetCircle = BABYLON.MeshBuilder.CreateDisc("target", {radius: 0.5, tessellation: 0}, scene);
        targetCircle.position.y = 0.1;
        targetCircle.position.x = -8;
        targetCircle.position.z = -8;
        targetCircle.rotation.x = Math.PI / 2;
        var targetMaterial = new BABYLON.StandardMaterial("targetMat", scene);
        targetMaterial.diffuseColor = new BABYLON.Color3(0.25, 0.25, 0.25);
        targetCircle.material = targetMaterial;

        createWalls();
    }

    function createWalls() {
        const wallHeight = 1;

        const wallConfigs = [
            {position: new BABYLON.Vector3(0, wallHeight / 2, -10), size: {height: wallHeight, width: 20, depth: 1}},
            {position: new BABYLON.Vector3(0, wallHeight / 2, 10), size: {height: wallHeight, width: 20, depth: 1}},
            {position: new BABYLON.Vector3(-10, wallHeight / 2, 0), size: {height: wallHeight, width: 1, depth: 20}},
            {position: new BABYLON.Vector3(10, wallHeight / 2, 0), size: {height: wallHeight, width: 1, depth: 20}},
            {position: new BABYLON.Vector3(0, -0.5, 0), size: {height: 1, width: 20, depth: 20}}
        ];

        wallConfigs.forEach(config => createWall(config.position, config.size));
    }

    function createWall(position, size) {
        var wall = BABYLON.MeshBuilder.CreateBox("wall", size, scene);
        wall.position = position;
        wall.physicsImpostor = new BABYLON.PhysicsImpostor(wall, BABYLON.PhysicsImpostor.BoxImpostor, {
            mass: 0,
            restitution: 0.9
        }, scene);
    }

    function updateCoordinates() {
        var coords = `X: ${sphere.position.x.toFixed(0)}, Y: ${sphere.position.y.toFixed(0)}, Z: ${sphere.position.z.toFixed(0)}`;
        document.getElementById('coordinateDisplay').innerText = coords;

        checkIfInsideTarget();
    }

    function startSimulationTimeout() {
        countdown = 10;
        updateCountdownDisplay();
        clearTimeout(simulationTimeoutId);
        simulationTimeoutId = setInterval(function () {
            countdown -= 1;
            updateCountdownDisplay();

            if (countdown <= 0) {
                //console.log("Simulation timed out! Resetting...");
                clearInterval(simulationTimeoutId);
                failCount++;
                updateScoreDisplay();
                resetSimulation();
            }
        }, 1000);

    }

    function updateScoreDisplay() {
        document.getElementById('successCount').innerText = 'Success: ' + successCount;
        document.getElementById('failCount').innerText = 'Fail: ' + failCount;
    }

    function updateCountdownDisplay() {
        document.getElementById('countdownTimer').innerText = countdown.toString();
    }

    function checkIfInsideTarget() {
        var distance = BABYLON.Vector3.Distance(sphere.position, targetCircle.position);
        if (distance < 0.5 && !targetReached) {
            targetReached = true;
            enableRandomMovement = false;
            clearTimeout(simulationTimeoutId);
            successCount++;
            updateScoreDisplay();
            freezeBall();
            setTimeout(resetSimulation, 1000);
        }
    }

    function freezeBall() {
        if (sphere.physicsImpostor) {
            sphere.physicsImpostor.setLinearVelocity(BABYLON.Vector3.Zero());
            sphere.physicsImpostor.setAngularVelocity(BABYLON.Vector3.Zero());
        }
    }

    var movements = {
        'w': new BABYLON.Vector3(0, 0, -1),
        'a': new BABYLON.Vector3(1, 0, 0),
        's': new BABYLON.Vector3(0, 0, 1),
        'd': new BABYLON.Vector3(-1, 0, 0),
        'wa': new BABYLON.Vector3(1, 0, -1),
        'wd': new BABYLON.Vector3(-1, 0, -1),
        'sa': new BABYLON.Vector3(1, 0, 1),
        'sd': new BABYLON.Vector3(-1, 0, 1)
    };

    function randomMovement() {
        if (!enableRandomMovement) return;
        if (new Date().getTime() - lastMoveTime > moveInterval) {
            var keys = Object.keys(movements);
            var randomKey = keys[Math.floor(Math.random() * keys.length)];
            moveSphere(movements[randomKey]);
            //console.log(randomKey);
            lastMoveTime = new Date().getTime();
        }
    }

    function moveSphere(direction) {
        var reducedSpeed = movementSpeed * 0.5;
        var forceDirection = direction.clone().normalize().scale(reducedSpeed);
        sphere.physicsImpostor.applyImpulse(forceDirection, sphere.getAbsolutePosition());
    }

    function reapplyWallPhysics() {
        scene.meshes.forEach(mesh => {
            if (mesh.name === "wall") {
                mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.BoxImpostor, {
                    mass: 0,
                    restitution: 0.9
                }, scene);
            }
        });
    }

    function resetSimulation() {
        //console.log("Resetting simulation");
        targetReached = false;

        sphere.position = new BABYLON.Vector3(0, 1, 8);

        if (sphere.physicsImpostor) {
            sphere.physicsImpostor.setLinearVelocity(BABYLON.Vector3.Zero());
            sphere.physicsImpostor.setAngularVelocity(BABYLON.Vector3.Zero());
        }

        scene.meshes.forEach(mesh => {
            if (mesh.name.startsWith("wall")) {
                mesh.physicsImpostor.dispose();
                mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.BoxImpostor, {
                    mass: 0,
                    restitution: 0.9
                }, scene);
            }
        });

        enableRandomMovement = false;
        startSimulationTimeout();
    }

    function moveToTarget() {
        if (!targetReached) {
            var targetDirection = targetCircle.position.subtract(sphere.position);
            targetDirection = targetDirection.normalize().scale(movementSpeed);
            sphere.physicsImpostor.applyImpulse(targetDirection, sphere.getAbsolutePosition());
        }
    }

    function randomOrTargetedMovement() {
        var currentTime = new Date().getTime();
        if (currentTime - lastMoveTime > moveInterval) {
            if (enableRandomMovement) {
                var keys = Object.keys(movements);
                var randomKey = keys[Math.floor(Math.random() * keys.length)];
                moveSphere(movements[randomKey]);
            } else {
                moveToTarget();
            }
            lastMoveTime = currentTime;
        }
    }

    function initialize() {
        canvas = document.getElementById('renderCanvas');
        engine = new BABYLON.Engine(canvas, true);
        createScene();

        let fpsDisplayUpdateInterval = 1000, lastFpsUpdateTime = 0, lastRenderTime = Date.now();

        engine.runRenderLoop(function () {
            let now = Date.now(), deltaTime = now - lastRenderTime;
            lastRenderTime = now;

            if (deltaTime > 100) {
                if (sphere.physicsImpostor) {
                    sphere.physicsImpostor.setLinearVelocity(BABYLON.Vector3.Zero());
                    sphere.physicsImpostor.setAngularVelocity(BABYLON.Vector3.Zero());
                }
            }

            if (document.visibilityState === 'visible') {
                scene.render();
                updateCoordinates();
                if (now - lastFpsUpdateTime > fpsDisplayUpdateInterval) {
                    document.getElementById('fpsCounter').innerText = `${engine.getFps().toFixed(0)} fps`;
                    lastFpsUpdateTime = now;
                }
            }
        });

        window.addEventListener('resize', () => engine.resize());

        //setInterval(randomMovement, 200);
        setInterval(randomOrTargetedMovement, 200);

        document.addEventListener('visibilitychange', () => lastRenderTime = Date.now());
    }

    window.addEventListener('DOMContentLoaded', function () {
        initialize();
        resetSimulation();
        updateScoreDisplay();
    });

    startSimulationTimeout();
</script>
</body>
</html>