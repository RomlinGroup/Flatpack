import argparse
import cv2
import mss
import numpy as np
import signal
import time
import torch

from PIL import Image
from threading import Thread
from transformers import TextIteratorStreamer, AutoTokenizer, AutoModelForCausalLM

try:
    from moondream import detect_device, LATEST_REVISION
except ImportError:
    # Define a custom detect_device function if import fails
    def detect_device():
        """
        Detect the appropriate device (CUDA, MPS, or CPU).
        Returns:
            tuple: A tuple containing the device and the corresponding data type.
        """
        if torch.cuda.is_available():
            return torch.device("cuda"), torch.float16
        if torch.backends.mps.is_available():
            return torch.device("mps"), torch.float16
        return torch.device("cpu"), torch.float32

    LATEST_REVISION = "main"

# Argument parser for CPU option and capture mode
parser = argparse.ArgumentParser()
parser.add_argument("--cpu", action="store_true")
parser.add_argument("--mode", choices=["screenshot", "webcam"], required=True,
                    help="Capture mode: 'screenshot' or 'webcam'")
args = parser.parse_args()

# Determine device
if args.cpu:
    device = torch.device("cpu")
    dtype = torch.float32
else:
    device, dtype = detect_device()
    if device != torch.device("cpu"):
        print("Using device:", device)
        print("If you run into issues, pass the `--cpu` flag to this script.")
        print()

# Load model and tokenizer
model_id = "vikhyatk/moondream2"
tokenizer = AutoTokenizer.from_pretrained(model_id, revision=LATEST_REVISION)
moondream = AutoModelForCausalLM.from_pretrained(
    model_id, trust_remote_code=True, revision=LATEST_REVISION
).to(device=device, dtype=dtype)
moondream.eval()


def cleanup(camera=None):
    """
    Perform any necessary cleanup.

    Args:
        camera (cv2.VideoCapture, optional): The webcam capture object to be released, if using webcam.
    """
    if camera and camera.isOpened():
        camera.release()
    cv2.destroyAllWindows()
    print("Cleanup complete.")


def signal_handler(sig, frame):
    """
    Handle termination signals to perform cleanup.

    Args:
        sig (int): The signal number.
        frame (frame): The current stack frame.
    """
    cleanup()
    exit(0)


# Register signal handler for graceful termination
signal.signal(signal.SIGINT, signal_handler)
signal.signal(signal.SIGTERM, signal_handler)


def answer_question(img, prompt):
    """
    Generate an answer to a question based on the provided image.

    Args:
        img (PIL.Image.Image): The image in PIL format.
        prompt (str): The question prompt to be answered.

    Returns:
        str: The response generated by the model.
    """
    image_embeds = moondream.encode_image(img)
    streamer = TextIteratorStreamer(tokenizer, skip_special_tokens=True)
    thread = Thread(
        target=moondream.answer_question,
        kwargs={
            "image_embeds": image_embeds,
            "question": prompt,
            "tokenizer": tokenizer,
            "streamer": streamer,
        },
    )
    thread.start()
    thread.join()  # Wait for the thread to complete

    buffer = ''.join(streamer)
    return buffer.strip()


def capture_screenshot(sct, monitor):
    screenshot = sct.grab(monitor)
    return Image.frombytes("RGB", (screenshot.width, screenshot.height), screenshot.rgb)


def capture_webcam_frame(cap):
    ret, frame = cap.read()
    if not ret:
        print("‚ùå Error: Could not read frame.")
        return None
    return Image.fromarray(cv2.cvtColor(frame, cv2.COLOR_BGR2RGB))


def main():
    """Main function to capture frames based on the selected mode."""
    frame_count = 0
    prompt = "What's going on? Respond with a single sentence."
    capture_interval = 5  # seconds

    if args.mode == "screenshot":
        with mss.mss() as sct:
            monitor = sct.monitors[0]  # Use the first monitor
            try:
                while True:
                    start_time = time.time()
                    img = capture_screenshot(sct, monitor)

                    frame_count += 1
                    width, height = img.size
                    print(f"üì∑ Captured frame {frame_count}: resolution {width}x{height}")

                    response = answer_question(img, prompt)
                    print(f"üåô Moondream analysis: {response}")

                    elapsed_time = time.time() - start_time
                    time.sleep(max(0, capture_interval - elapsed_time))
            finally:
                cleanup()
    elif args.mode == "webcam":
        cap = cv2.VideoCapture(0)
        if not cap.isOpened():
            print("‚ùå Error: Could not open webcam.")
            return

        try:
            while True:
                start_time = time.time()
                img = capture_webcam_frame(cap)
                if img is None:
                    break

                frame_count += 1
                width, height = img.size
                print(f"üì∑ Captured frame {frame_count}: resolution {width}x{height}")

                response = answer_question(img, prompt)
                print(f"üåô Moondream analysis: {response}")

                elapsed_time = time.time() - start_time
                time.sleep(max(0, capture_interval - elapsed_time))
        finally:
            cleanup(cap)


if __name__ == "__main__":
    main()
