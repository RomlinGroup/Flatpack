<!DOCTYPE html>
<html>

<head>
	<title>Cobot</title>
	<style>
		body {
			margin: 0;
		}

		canvas {
			display: block;
		}

		#demoStatus {
			position: fixed;
			top: 10px;
			left: 10px;
			padding: 10px;
			background: rgba(255, 255, 255, 0.8);
			border-radius: 5px;
			font-family: Arial, sans-serif;
			font-size: 14px;
			color: #333
		}

		#forearmView {
			position: fixed;
			top: 10px;
			right: 10px;
			width: 250px;
			height: 150px;
			border: 1px solid black;
			border: 1px solid #fff;
		}

		#keyGuide {
			position: fixed;
			bottom: 10px;
			right: 10px;
			padding: 10px;
			background: rgba(0, 0, 0, 1);
			border-radius: 5px;
			font-family: Arial, sans-serif;
			font-size: 14px;
			color: #ffffff;
		}

		#positionDisplay {
			position: fixed;
			bottom: 10px;
			left: 10px;
			padding: 10px;
			background: rgba(0, 0, 0, 1);
			border-radius: 5px;
			font-family: Arial, sans-serif;
			font-size: 14px;
			color: #ffffff;
		}
	</style>
</head>

<body>
	<div id="forearmView"></div>

	<div id="positionDisplay">
		Position: x: 0, y: 0, z: 0
	</div>


	<div id="demoStatus">
		Demo Mode: OFF
	</div>


	<!-- Controls Guide -->
	<div id="keyGuide">
		<strong>Controls:</strong><br>
		Base - Q/E<br>
		Upper Arm - W/S<br>
		Forearm - R/F<br>
		Open Pincers - O<br>
		Close Pincers - P<br>
		Rotate Pincers - T/Y<br>
		Toggle Demo Mode - M
	</div>

	<!-- Three.js and OrbitControls Scripts -->
	<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
	<script src="CannonDebugRenderer.js"></script>

	<!-- Main Script for Robot Arm Simulation -->
	<script>
		// Constants and Configuration
		const ARM_COLORS = {
			base: 0xffffff,
			shoulder: 0xffffff,
			upperArm: 0xffffff,
			forearm: 0xffffff
		};

		let world, scene, camera, renderer, controls;
		let base, shoulder, upperArm, elbow, forearm;
		let pincerClosing = true;
		let pincerAngle = 0;
		const pincerSpeed = 0.005;
		const maxPincerAngle = Math.PI / 5;
		let pincerClaw1, pincerClaw2;
		let demoMode = false;
		const demoSpeed = 0.01;
		let forearmRotation = 0;
		let fullCycleCount = 0;
		const maxCycles = 1;
		let sphereDot;
		let sphereDotBody;
		let boxBody;
		let forearmCamera, forearmRenderer;
		let forearmCameraIsActive = true;

		// Initialize Scene, Camera, and Renderer
		function init() {
			world = new CANNON.World();
			world.gravity.set(0, -9.82, 0); // Earth's gravity acceleration in meters per second squared

			setupScene();

			cannonDebugRenderer = new THREE.CannonDebugRenderer(scene, world);

			addPhysicsBox();
			setupCamera();
			setupRenderer();
			addLighting();
			addFloor();
			addRobotArm();
			setupControls();

			// Initialize the forearm camera and renderer
			initForearmCamera();

			animate();
		}

		function initForearmCamera() {
			// Create the forearm camera
			const fov = 60; // Field of View (degrees)
			const aspect = 16 / 9; // Aspect ratio (width/height)
			forearmCamera = new THREE.PerspectiveCamera(fov, aspect, 0.1, 1000);

			// Create a renderer for the forearm view with similar settings to the main renderer
			forearmRenderer = new THREE.WebGLRenderer({
				antialias: true
			});
			forearmRenderer.setSize(250, 150); // Match the size of the #forearmView div
			forearmRenderer.gammaFactor = 2.2;
			forearmRenderer.outputEncoding = THREE.sRGBEncoding;
			forearmRenderer.shadowMap.enabled = true;
			forearmRenderer.shadowMap.type = THREE.PCFSoftShadowMap; // Optional, for softer shadows

			document.getElementById('forearmView').appendChild(forearmRenderer.domElement);
		}

		function setupScene() {
			scene = new THREE.Scene();

			// Create a grid helper
			const gridSize = 10; // Size of the grid
			const gridDivisions = 10; // Number of divisions
			const gridHelper = new THREE.GridHelper(gridSize, gridDivisions);
			scene.add(gridHelper);
		}


		// Setup the Camera
		function setupCamera() {
			camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
			camera.position.set(2, 1, 2);
		}

		// Setup the Renderer
		function setupRenderer() {
			renderer = new THREE.WebGLRenderer({
				antialias: true
			});
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.gammaFactor = 2.2;
			renderer.outputEncoding = THREE.sRGBEncoding; // Updated line
			document.body.appendChild(renderer.domElement);
		}

		// Add Lighting to the Scene
		function addLighting() {
			// Existing Directional Light
			const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
			directionalLight.position.set(0, 10, 10).normalize();
			directionalLight.castShadow = true;
			scene.add(directionalLight);

			// Add a Point Light
			const pointLight = new THREE.PointLight(0xffffff, 1, 100);
			pointLight.position.set(10, 10, 10);
			scene.add(pointLight);

			// Ambient Light
			const ambientLight = new THREE.AmbientLight(0x404040); // Soft white light
			scene.add(ambientLight);
		}

		// Function to add a physics box to the scene
		function addPhysicsBox() {
			// Three.js box
			const boxGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.5); // Box size
			const boxMaterial = new THREE.MeshStandardMaterial({
				color: 0x5865f2
			}); // Box color
			const boxMesh = new THREE.Mesh(boxGeometry, boxMaterial);
			boxMesh.position.set(1, 0.25, 1); // Box initial position (x, y, z)

			scene.add(boxMesh);

			// Cannon.js physics body
			const boxShape = new CANNON.Box(new CANNON.Vec3(0.25, 0.25, 0.25)); // Half extents of the box
			boxBody = new CANNON.Body({
				mass: 10,
				restitution: 0.5,
				shape: boxShape,
				position: new CANNON.Vec3(1, 0.25, 1) // Match the Three.js position
			});
			world.addBody(boxBody);
			boxMesh.userData.physicsBody = boxBody;
			boxBody.addEventListener('collide', function(e) {
				//console.log('Box collided with', e.body);
			});
		}

		// Add Robot Arm Components to the Scene
		function addRobotArm() {
			base = createSegment(0.5, 0.6, 0.3, ARM_COLORS.base, 0.15);
			base.castShadow = true;
			base.receiveShadow = true;

			shoulder = createSegment(0, 0, 0.3, ARM_COLORS.shoulder, 0.15);
			shoulder.castShadow = true;
			shoulder.receiveShadow = true;

			upperArm = createSegment(0.15, 0.15, 1.2, ARM_COLORS.upperArm, 0.6);
			upperArm.castShadow = true;
			upperArm.receiveShadow = true;

			// Create the green elbow joint sphere
			const elbowGeometry = new THREE.SphereGeometry(0.15, 32, 32);
			const elbowMaterial = new THREE.MeshStandardMaterial({
				color: 0xffffff
			});
			elbow = new THREE.Mesh(elbowGeometry, elbowMaterial);
			elbow.position.y = 0.6;
			elbow.castShadow = true;
			elbow.receiveShadow = true;

			forearm = createSegment(0.1, 0.1, 1.0, ARM_COLORS.forearm, 0.5);

			scene.add(base);
			base.add(shoulder);
			shoulder.add(upperArm);
			upperArm.add(elbow); // Add the elbow joint to the upper arm
			elbow.add(forearm);

			// Set the initial rotation of the shoulder to the maximum downward angle within the constraints
			shoulder.rotation.x = THREE.MathUtils.degToRad(-30); // Convert -65 degrees to radians

			// Set the initial rotation of the elbow to the maximum downward angle within the constraints
			elbow.rotation.x = THREE.MathUtils.degToRad(-90); // Convert -90 degrees to radians

			// Create Pincers
			const pincerMaterial = new THREE.MeshStandardMaterial({
				color: 0xffffff
			}); // Yellow color for pincers
			const pincerBaseGeometry = new THREE.BoxGeometry(0.1, 0.05, 0.05);
			const pincerBase1 = new THREE.Mesh(pincerBaseGeometry, pincerMaterial);
			const pincerBase2 = new THREE.Mesh(pincerBaseGeometry, pincerMaterial);
			const pincerClawGeometry = new THREE.BoxGeometry(0.1, 0.01, 0.1);
			pincerClaw1 = new THREE.Mesh(pincerClawGeometry, pincerMaterial);
			pincerClaw2 = new THREE.Mesh(pincerClawGeometry, pincerMaterial);

			pincerBase1.position.set(0.05, 0.5, 0);
			pincerBase2.position.set(-0.05, 0.5, 0);
			pincerBase1.rotation.x = Math.PI / 2;
			pincerBase2.rotation.x = Math.PI / 2;
			pincerBase1.rotation.z = 55;
			pincerBase2.rotation.z = -55;
			forearm.add(pincerBase1);
			forearm.add(pincerBase2);

			pincerClaw1.position.set(0, 0.02, -0.05);
			pincerClaw2.position.set(0, 0.02, -0.05);
			pincerClaw1.rotation.x = 0;
			pincerClaw2.rotation.x = 0;
			pincerClaw1.rotation.z = 0;
			pincerClaw2.rotation.z = 0;
			pincerBase1.add(pincerClaw1);
			pincerBase2.add(pincerClaw2);

			const dotGeometry = new THREE.SphereGeometry(0.05, 32, 32);
			const dotMaterial = new THREE.MeshBasicMaterial({
				color: 0x00ff00
			});
			sphereDot = new THREE.Mesh(dotGeometry, dotMaterial);
			sphereDot.position.set(0, forearm.geometry.parameters.height / 2 + 0.1, 0);
			forearm.add(sphereDot);

			const sphereDotShape = new CANNON.Sphere(0.05);
			sphereDotBody = new CANNON.Body({
				mass: 0,
				restitution: 0.5,
				shape: sphereDotShape,
				position: new CANNON.Vec3(0, 2, 0)
			});
			world.addBody(sphereDotBody);
			forearm.userData.physicsBody = sphereDotBody;
			sphereDotBody.addEventListener('collide', function(e) {
				//console.log('Box collided with', e.body);
			});

		}

		// Create a Segment of the Robot Arm
		function createSegment(topRadius, bottomRadius, height, color, yPos) {
			var geometry, segment;

			if (topRadius === 0 && bottomRadius === 0) {
				// Create a sphere geometry since the top and bottom radius are 0
				geometry = new THREE.SphereGeometry(height, 32, 32);
				var material = new THREE.MeshStandardMaterial({
					color: color,
					metalness: 0.5,
					roughness: 0.4
				});
				segment = new THREE.Mesh(geometry, material);
			} else {
				// Create a cylinder geometry
				geometry = new THREE.CylinderGeometry(topRadius, bottomRadius, height, 32);
				var material = new THREE.MeshStandardMaterial({
					color: color
				});
				segment = new THREE.Mesh(geometry, material);
			}

			segment.position.y = yPos;
			return segment;
		}

		// Add Floor to the Scene with Grey Background and Black Grid Pattern
		// Add Floor to the Scene with Grey Background and Black Grid Pattern
		function addFloor() {

			// Create a grey background plane
			const backgroundGeometry = new THREE.PlaneGeometry(10, 10);
			const backgroundMaterial = new THREE.MeshStandardMaterial({
				color: 0x777777,
				side: THREE.DoubleSide,
			});
			const background = new THREE.Mesh(backgroundGeometry, backgroundMaterial);
			background.rotation.x = -Math.PI / 2;
			background.position.y = -0.01;
			scene.add(background);

			// Create a black grid pattern on top of the background
			const gridGeometry = new THREE.PlaneGeometry(10, 10, 10, 10);
			const gridMaterial = new THREE.MeshBasicMaterial({
				color: 0x000000,
				side: THREE.DoubleSide,
				transparent: true,
				opacity: 0.5,
				wireframe: true,
			});
			const grid = new THREE.Mesh(gridGeometry, gridMaterial);
			grid.rotation.x = -Math.PI / 2;
			grid.position.y = 0.001; // Slightly above the grey background
			scene.add(grid);

			// Create a physics body for the floor
			var floorShape = new CANNON.Plane();
			var floorBody = new CANNON.Body({
				mass: 0
			});
			floorBody.addShape(floorShape);
			floorBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0); // Align horizontally
			world.addBody(floorBody);

			// Visual representation of the Cannon.js floor
			const floorVisualGeometry = new THREE.PlaneGeometry(10, 10);
			const floorVisualMaterial = new THREE.MeshBasicMaterial({
				color: 0x00ff00, // Bright green for visibility
				side: THREE.DoubleSide,
				transparent: true,
				opacity: 0.5,
				wireframe: true
			});
			const floorVisual = new THREE.Mesh(floorVisualGeometry, floorVisualMaterial);
			floorVisual.rotation.x = -Math.PI / 2;
			floorVisual.position.y = -0.01;
			scene.add(floorVisual);
		}

		// Setup Controls for the Scene
		function setupControls() {
			controls = new THREE.OrbitControls(camera, renderer.domElement);
			controls.target.set(0, 1, 0);
			controls.update();
			document.addEventListener("keydown", onDocumentKeyDown, false);
		}

		function animate() {
			requestAnimationFrame(animate);

			if (world) {
				// Calculate the force needed to move the sphereDot towards a target position
				var targetPosition = new CANNON.Vec3(1, 0, 1); // replace with your target position
				var forceDirection = targetPosition.vsub(sphereDotBody.position);
				forceDirection.normalize();
				var forceMagnitude = 5; // replace with the desired force magnitude
				var force = forceDirection.scale(forceMagnitude);

				// Apply the force to the sphereDotBody at its center
				sphereDotBody.applyForce(force, sphereDotBody.position);

				// Step the physics world
				world.step(1 / 60);

				// Update positions and quaternions after stepping the world
				scene.children.forEach(function(child) {
					if (child.userData.physicsBody) {
						child.position.copy(child.userData.physicsBody.position);
						child.quaternion.copy(child.userData.physicsBody.quaternion);
					}
				});

				// Update sphereDotBody's position and quaternion
				var worldPosition = new THREE.Vector3();
				sphereDot.getWorldPosition(worldPosition);
				sphereDotBody.position.copy(worldPosition);

				var worldQuaternion = new THREE.Quaternion();
				sphereDot.getWorldQuaternion(worldQuaternion);
				sphereDotBody.quaternion.copy(worldQuaternion);

				// Update Cannon Debug Renderer
				cannonDebugRenderer.update();

				// Render the main scene
				renderer.render(scene, camera);

				if (forearmCameraIsActive) {
					forearmRenderer.render(scene, forearmCamera);
				}
			}

			// Update the position display
			if (sphereDot) {
				const pos = sphereDotBody.position;
				document.getElementById("positionDisplay").innerText = `x: ${pos.x.toFixed(2)}, y: ${pos.y.toFixed(2)}, z: ${pos.z.toFixed(2)}`;
			}

			// Optional: Implement any additional animations or state updates
			if (demoMode) {
				automatedMovements();
			}

			if (forearmCamera && sphereDot) {
				// Position the camera at the sphereDot
				var sphereDotPosition = new THREE.Vector3();
				sphereDot.getWorldPosition(sphereDotPosition);
				forearmCamera.position.copy(sphereDotPosition);

				// Orient the camera to look forward from the forearm
				var forearmDirection = new THREE.Vector3(0, 0, -1); // Assuming the forearm points along the negative Z-axis
				forearm.getWorldDirection(forearmDirection);
				forearmCamera.lookAt(forearmDirection.add(sphereDotPosition));

				// Rotate the camera 90 degrees upwards
				forearmCamera.rotateX(THREE.MathUtils.degToRad(-90));

				// Render the forearm camera view
				forearmRenderer.render(scene, forearmCamera);
			}

			// Render the main scene
			renderer.render(scene, camera);
		}

		// Clamp Rotation Function
		function clampRotation(currentRotation, minAngle, maxAngle) {
			const minRadians = THREE.MathUtils.degToRad(minAngle);
			const maxRadians = THREE.MathUtils.degToRad(maxAngle);
			return Math.max(minRadians, Math.min(maxRadians, currentRotation));
		}

		// Function to open the pincers (straight out)
		function openPincers() {
			pincerClaw1.position.set(0, 0.02, -0.05);
			pincerClaw2.position.set(0, 0.02, -0.05);
		}

		// Function to close the pincers (reset to default position)
		function closePincers() {
			pincerClaw1.position.set(0, -0.02, -0.05);
			pincerClaw2.position.set(0, -0.02, -0.05);
		}

		// Variables to track movement state
		let movementStep = 0;
		let isPincerOpen = false;

		function automatedMovements() {
			switch (movementStep) {
				case 0:
					// Rotate base
					rotateBase(1);
					fullCycleCount += demoSpeed;
					if (fullCycleCount >= 2 * Math.PI) { // Full rotation
						fullCycleCount = 0; // Reset the cycle count
						movementStep++;
					}
					movementStep = 0;
					break;
			}
		}

		// Movement functions
		function rotateBase(direction) {
			const delta = (demoMode ? demoSpeed : 0.05) * direction;
			base.rotation.y += delta;
		}

		function moveShoulder(direction) {
			const delta = (demoMode ? demoSpeed : 0.05) * direction;
			shoulder.rotation.x += delta;
			shoulder.rotation.x = clampRotation(shoulder.rotation.x, -45, 0);
		}

		function moveElbow(direction) {
			const delta = (demoMode ? demoSpeed : 0.05) * direction;
			elbow.rotation.x += delta;
			elbow.rotation.x = clampRotation(elbow.rotation.x, -130, 0);
		}

		function rotateForearm(direction) {
			const rotationSpeed = demoMode ? demoSpeed : 0.1;
			forearmRotation += direction * rotationSpeed;
			forearm.rotation.y = forearmRotation;

			// Update the physics body's quaternion and position
			var quaternion = new THREE.Quaternion();
			forearm.getWorldQuaternion(quaternion);
			forearm.userData.physicsBody.quaternion.copy(quaternion);

			var worldPosition = new THREE.Vector3();
			forearm.getWorldPosition(worldPosition);
			forearm.userData.physicsBody.position.copy(worldPosition);
		}

		// Handle Keyboard Inputs
		function onDocumentKeyDown(event) {
			var keyCode = event.which;

			if (!demoMode) {
				if (keyCode == 81) {
					rotateBase(-1);
				} // Q
				else if (keyCode == 69) {
					rotateBase(1);
				} // E
				else if (keyCode == 87) {
					moveShoulder(1);
				} // W
				else if (keyCode == 83) {
					moveShoulder(-1);
				} // S
				else if (keyCode == 82) {
					moveElbow(1);
				} // R
				else if (keyCode == 70) {
					moveElbow(-1);
				} // F
				else if (keyCode == 79) {
					openPincers();
				} // O
				else if (keyCode == 80) {
					closePincers();
				} // P
				else if (keyCode == 84) {
					rotateForearm(1);
				} // T
				else if (keyCode == 89) {
					rotateForearm(-1);
				} // Y
			}

			if (keyCode == 77) {
				demoMode = !demoMode;
				document.getElementById("demoStatus").innerText = "Demo Mode: " + (demoMode ? "ON" : "OFF");
			} // M
		}

		init();
	</script>
</body>

</html>