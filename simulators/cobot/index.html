<!DOCTYPE html>
<html>

<head>
	<title>Cobot</title>
	<style>
		body {
			margin: 0;
		}

		canvas {
			display: block;
		}

		#demoStatus {
			position: fixed;
			top: 10px;
			left: 10px;
			padding: 10px;
			background: rgba(255, 255, 255, 0.8);
			border-radius: 5px;
			font-family: Arial, sans-serif;
			font-size: 14px;
			color: #333
		}

		#forearmView {
			position: fixed;
			top: 10px;
			right: 10px;
			width: 250px;
			height: 150px;
			border: 1px solid black;
			border: 1px solid #fff;
		}

		#keyGuide {
			position: fixed;
			bottom: 10px;
			right: 10px;
			padding: 10px;
			background: rgba(0, 0, 0, 1);
			border-radius: 5px;
			font-family: Arial, sans-serif;
			font-size: 14px;
			color: #ffffff;
		}

		#positionDisplay {
			position: fixed;
			bottom: 10px;
			left: 10px;
			padding: 10px;
			background: rgba(0, 0, 0, 1);
			border-radius: 5px;
			font-family: Arial, sans-serif;
			font-size: 14px;
			color: #ffffff;
		}
	</style>
</head>

<body>
	<div id="forearmView"></div>

	<div id="positionDisplay">
		Position: x: 0, y: 0, z: 0
	</div>

	<div id="demoStatus">
		Demo Mode: OFF
	</div>

	<div id="keyGuide">
		<strong>Controls:</strong><br>
		Base - A/D<br>
		Upper Arm - W/S<br>
		Forearm - R/F<br>
		Toggle Demo Mode - M
	</div>

	<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/cannon@0.6.2/tools/threejs/CannonDebugRenderer.js"></script>

	<script>
		const demoSpeed = 0.01;
		let base;
		let boxBody;
		let camera;
		let controls;
		let demoMode = false;
		let elbow;
		let forearm;
		let forearmCamera;
		let forearmRenderer;
		let forearmCameraIsActive = true;
		let fullCycleCount = 0;
		let pincerBase;
		let pincerClaw1;
		let pincerClaw2;
		let renderer;
		let scene;
		let shoulder;
		let upperArm;
		let world;

		function init() {
			world = new CANNON.World();
			world.gravity.set(0, -9.82, 0);

			setupScene();

			cannonDebugRenderer = new THREE.CannonDebugRenderer(scene, world);

			addPhysicsBox();
			setupCamera();
			setupRenderer();
			addLighting();
			addFloor();
			addRobotArm();
			setupControls();
			initForearmCamera();
			animate();
		}

		function initForearmCamera() {
			const aspect = 16 / 9;
			const fov = 60;
			forearmCamera = new THREE.PerspectiveCamera(fov, aspect, 0.1, 1000);
			forearmRenderer = new THREE.WebGLRenderer({
				antialias: true
			});
			forearmRenderer.setSize(250, 150);
			forearmRenderer.gammaFactor = 2.0;
			forearmRenderer.outputEncoding = THREE.sRGBEncoding;
			forearmRenderer.shadowMap.enabled = true;
			forearmRenderer.shadowMap.type = THREE.PCFSoftShadowMap;
			document.getElementById('forearmView').appendChild(forearmRenderer.domElement);
		}

		function setupScene() {
			scene = new THREE.Scene();
			const gridSize = 10;
			const gridDivisions = 10;
			const gridHelper = new THREE.GridHelper(gridSize, gridDivisions);
			scene.add(gridHelper);
		}

		function setupCamera(
			fov = 75,
			aspectRatio = window.innerWidth / window.innerHeight,
			nearClippingPlane = 0.1,
			farClippingPlane = 1000,
			initialPosition = {
				x: 2,
				y: 1,
				z: 0
			},
			lookAtPosition = {
				x: 0,
				y: 0,
				z: 0
			}
		) {
			camera = new THREE.PerspectiveCamera(fov, aspectRatio, nearClippingPlane, farClippingPlane);
			camera.position.set(initialPosition.x, initialPosition.y, initialPosition.z);
			camera.lookAt(lookAtPosition.x, lookAtPosition.y, lookAtPosition.z);

			window.addEventListener('resize', () => {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
			});
		}

		function setupRenderer() {
			renderer = new THREE.WebGLRenderer({
				antialias: true
			});
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.gammaFactor = 2.0;
			renderer.outputEncoding = THREE.sRGBEncoding;
			document.body.appendChild(renderer.domElement);
		}

		function addLighting() {
			const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
			directionalLight.position.set(0, 10, 10).normalize();
			directionalLight.castShadow = true;
			scene.add(directionalLight);

			const pointLight = new THREE.PointLight(0xffffff, 1, 100);
			pointLight.position.set(10, 10, 10);
			scene.add(pointLight);

			const ambientLight = new THREE.AmbientLight(0x404040);
			scene.add(ambientLight);
		}

		function pairMeshWithPhysicsBody(mesh, options = {}) {
			let shape;
			const geometry = mesh.geometry;
			const mass = options.mass !== undefined ? options.mass : 1;
			const isKinematic = options.isKinematic || false;

			if (geometry instanceof THREE.BoxGeometry) {
				const size = new CANNON.Vec3(geometry.parameters.width / 2, geometry.parameters.height / 2, geometry.parameters.depth / 2);
				shape = new CANNON.Box(size);
			} else if (geometry instanceof THREE.SphereGeometry) {
				const radius = geometry.parameters.radius;
				shape = new CANNON.Sphere(radius);
			}

			const body = new CANNON.Body({
				mass: isKinematic ? 0 : mass,
				material: new CANNON.Material({
					friction: options.friction || 0.3,
					restitution: options.restitution || 0.5,
				}),
				shape: shape,
				type: isKinematic ? CANNON.Body.KINEMATIC : CANNON.Body.DYNAMIC
			});

			body.position.set(mesh.position.x, mesh.position.y, mesh.position.z);
			body.quaternion.set(mesh.quaternion.x, mesh.quaternion.y, mesh.quaternion.z, mesh.quaternion.w);

			world.addBody(body);
			mesh.userData.physicsBody = body;
		}

		function addPhysicsBox() {
			const boxGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
			const boxMaterial = new THREE.MeshStandardMaterial({
				color: 0x5865f2
			});
			const boxMesh = new THREE.Mesh(boxGeometry, boxMaterial);

			boxMesh.position.set(0, 0.25, 1.25);
			scene.add(boxMesh);

			pairMeshWithPhysicsBody(boxMesh, {
				mass: 10,
				friction: 0.4,
				restitution: 0.6,
				isKinematic: false
			});
		}

		function addRobotArm() {

			const baseMaterial = new THREE.MeshStandardMaterial({
				color: 0x5865f2,
				metalness: 0.5,
				roughness: 0.4
			});

			const material = new THREE.MeshStandardMaterial({
				color: 0xffffff,
				metalness: 0.5,
				roughness: 0.4
			});

			const baseGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.2, 32);
			base = new THREE.Mesh(baseGeometry, baseMaterial);
			base.position.y = 0.1;

			const shoulderGeometry = new THREE.SphereGeometry(0.2, 32, 32);
			shoulder = new THREE.Mesh(shoulderGeometry, baseMaterial);
			shoulder.position.y = 0.1;
			const maxShoulderAngle = 45;
			shoulder.rotation.x = THREE.MathUtils.degToRad(maxShoulderAngle);

			const upperArmGeometry = new THREE.BoxGeometry(0.1, 1, 0.1);
			upperArm = new THREE.Mesh(upperArmGeometry, material);
			upperArm.position.y = 0.5;

			const elbowGeometry = new THREE.CylinderGeometry(0.15, 0.15, 0.15, 32);
			const elbowMaterial = new THREE.MeshStandardMaterial({
				color: 0x5865f2
			});
			elbow = new THREE.Mesh(elbowGeometry, elbowMaterial);
			elbow.position.y = 0.6;
			elbow.rotation.z = Math.PI / 2;
			elbow.castShadow = true;
			elbow.receiveShadow = true;
			const maxElbowAngle = 45;
			elbow.rotation.x = THREE.MathUtils.degToRad(maxElbowAngle);

			const forearmGeometry = new THREE.BoxGeometry(0.1, 0.1, 0.7);
			const forearmMaterial = new THREE.MeshStandardMaterial({
				color: 0xffffff
			});
			forearm = new THREE.Mesh(forearmGeometry, forearmMaterial);
			forearm.position.set(0, 0, 0.4);

			scene.add(base);
			base.add(shoulder);
			shoulder.add(upperArm);

			pairMeshWithPhysicsBody(upperArm, {
				mass: 0,
				friction: 0.4,
				restitution: 0.6,
				isKinematic: true
			});

			upperArm.add(elbow);
			elbow.add(forearm);

			pairMeshWithPhysicsBody(forearm, {
				mass: 0,
				friction: 0.4,
				restitution: 0.6,
				isKinematic: true
			});

			const pincerMaterial = new THREE.MeshStandardMaterial({
				color: 0x5865f2
			});
			const pincerBaseGeometry = new THREE.BoxGeometry(0.2, 0.4, 0.05);
			pincerBase = new THREE.Mesh(pincerBaseGeometry, pincerMaterial);
			const pincerClawGeometry = new THREE.BoxGeometry(0.2, 0.05, 0.2);
			pincerClaw1 = new THREE.Mesh(pincerClawGeometry, pincerMaterial);
			pincerClaw2 = new THREE.Mesh(pincerClawGeometry, pincerMaterial);

			forearm.add(pincerBase);
			pincerBase.position.set(0, 0, 0.36);

			pairMeshWithPhysicsBody(pincerBase, {
				mass: 0,
				friction: 0.4,
				restitution: 0.6,
				isKinematic: true
			});

			pincerClaw1.position.set(0, 0.2, 0.075);
			pincerClaw2.position.set(0, -0.2, 0.075);
			pincerBase.add(pincerClaw1);
			pincerBase.add(pincerClaw2);

			pairMeshWithPhysicsBody(pincerClaw1, {
				mass: 0,
				friction: 0.4,
				restitution: 0.6,
				isKinematic: true
			});

			pairMeshWithPhysicsBody(pincerClaw2, {
				mass: 0,
				friction: 0.4,
				restitution: 0.6,
				isKinematic: true
			});
		}

		function addFloor() {
			const backgroundGeometry = new THREE.PlaneGeometry(10, 10);
			const backgroundMaterial = new THREE.MeshStandardMaterial({
				color: 0x777777,
				side: THREE.DoubleSide,
			});
			const background = new THREE.Mesh(backgroundGeometry, backgroundMaterial);
			background.rotation.x = -Math.PI / 2;
			background.position.y = -0.01;
			scene.add(background);

			const gridGeometry = new THREE.PlaneGeometry(10, 10, 10, 10);
			const gridMaterial = new THREE.MeshBasicMaterial({
				color: 0x000000,
				side: THREE.DoubleSide,
				transparent: true,
				opacity: 0.5,
				wireframe: true,
			});
			const grid = new THREE.Mesh(gridGeometry, gridMaterial);
			grid.rotation.x = -Math.PI / 2;
			grid.position.y = 0.001;
			scene.add(grid);

			var floorShape = new CANNON.Plane();
			var floorBody = new CANNON.Body({
				mass: 0
			});
			floorBody.addShape(floorShape);
			floorBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
			world.addBody(floorBody);

			const floorVisualGeometry = new THREE.PlaneGeometry(10, 10);
			const floorVisualMaterial = new THREE.MeshBasicMaterial({
				color: 0x00ff00,
				side: THREE.DoubleSide,
				transparent: true,
				opacity: 0.5,
				wireframe: true
			});
			const floorVisual = new THREE.Mesh(floorVisualGeometry, floorVisualMaterial);
			floorVisual.rotation.x = -Math.PI / 2;
			floorVisual.position.y = -0.01;
			scene.add(floorVisual);
		}

		function setupControls() {
			controls = new THREE.OrbitControls(camera, renderer.domElement);
			controls.target.set(0, 1, 0);
			controls.update();
			document.addEventListener("keydown", onDocumentKeyDown, false);
		}

		function animate() {
			requestAnimationFrame(animate);

			if (world) {
				world.step(1 / 60);

				scene.traverse(function(object) {
					if (object.userData.physicsBody) {
						if (object.userData.physicsBody.type === CANNON.Body.DYNAMIC) {
							object.position.copy(object.userData.physicsBody.position);
							object.quaternion.copy(object.userData.physicsBody.quaternion);
						} else if (object.userData.physicsBody.type === CANNON.Body.KINEMATIC) {
							var worldPosition = new THREE.Vector3();
							var worldQuaternion = new THREE.Quaternion();
							object.getWorldPosition(worldPosition);
							object.getWorldQuaternion(worldQuaternion);
							object.userData.physicsBody.position.copy(worldPosition);
							object.userData.physicsBody.quaternion.copy(worldQuaternion);
						}
					}
				});

				cannonDebugRenderer.update();

				renderer.render(scene, camera);

				if (forearmCameraIsActive) {
					forearmRenderer.render(scene, forearmCamera);
				}
			}

			if (pincerBase && pincerBase.userData.physicsBody) {
				const pos = pincerBase.userData.physicsBody.position;
				document.getElementById("positionDisplay").innerText = `x: ${pos.x.toFixed(2)}, y: ${pos.y.toFixed(2)}, z: ${pos.z.toFixed(2)}`;
			}

			if (demoMode) {
				automatedMovements();
			}

			if (forearmCamera) {
				var pincerBasePosition = new THREE.Vector3();
				pincerBase.getWorldPosition(pincerBasePosition);
				forearmCamera.position.copy(pincerBasePosition);

				var forearmDirection = new THREE.Vector3(0, 0, -1);
				forearm.getWorldDirection(forearmDirection);
				forearmCamera.lookAt(forearmDirection.add(pincerBasePosition));
				forearmCamera.rotateX(THREE.MathUtils.degToRad(0));
				forearmRenderer.render(scene, forearmCamera);
			}

			renderer.render(scene, camera);
		}

		function clampRotation(currentRotation, minAngle, maxAngle) {
			const minRadians = THREE.MathUtils.degToRad(minAngle);
			const maxRadians = THREE.MathUtils.degToRad(maxAngle);
			return Math.max(minRadians, Math.min(maxRadians, currentRotation));
		}

		let movementStep = 0;

		function automatedMovements() {
			switch (movementStep) {
				case 0:
					rotateBase(1);
					fullCycleCount += demoSpeed;
					if (fullCycleCount >= 2 * Math.PI) {
						fullCycleCount = 0;
						movementStep++;
					}
					movementStep = 0;
					break;
			}
		}

		function rotateBase(direction) {
			const delta = (demoMode ? demoSpeed : 0.05) * direction;
			base.rotation.y += delta;
		}

		function moveShoulder(direction) {
			const delta = (demoMode ? demoSpeed : 0.05) * direction;
			shoulder.rotation.x += delta;
			shoulder.rotation.x = clampRotation(shoulder.rotation.x, 0, 45);
		}

		function moveElbow(direction) {
			const delta = (demoMode ? demoSpeed : 0.05) * direction;
			elbow.rotation.x += delta;
			elbow.rotation.x = clampRotation(elbow.rotation.x, -90, 45);
		}

		function onDocumentKeyDown(event) {
			var keyCode = event.which;

			if (!demoMode) {
				if (keyCode == 65) {
					rotateBase(1);
				} else if (keyCode == 68) {
					rotateBase(-1);
				} else if (keyCode == 87) {
					moveShoulder(-1);
				} else if (keyCode == 83) {
					moveShoulder(1);
				} else if (keyCode == 82) {
					moveElbow(-1);
				} else if (keyCode == 70) {
					moveElbow(1);
				}
			}

			if (keyCode == 77) {
				demoMode = !demoMode;
				document.getElementById("demoStatus").innerText = "Demo Mode: " + (demoMode ? "ON" : "OFF");
			}
		}

		init();
	</script>
</body>

</html>