<!DOCTYPE html>
<html>

<head>
	<title>Cobot</title>
	<style>
		body {
			margin: 0;
		}

		canvas {
			display: block;
		}

		#demoStatus {
			position: fixed;
			top: 10px;
			left: 10px;
			padding: 10px;
			background: rgba(255, 255, 255, 0.8);
			border-radius: 5px;
			font-family: Arial, sans-serif;
			font-size: 14px;
			color: #333
		}

		#forearmView {
			position: fixed;
			top: 10px;
			right: 10px;
			width: 250px;
			height: 150px;
			border: 1px solid black;
			border: 1px solid #fff;
		}

		#keyGuide {
			position: fixed;
			bottom: 10px;
			right: 10px;
			padding: 10px;
			background: rgba(0, 0, 0, 1);
			border-radius: 5px;
			font-family: Arial, sans-serif;
			font-size: 14px;
			color: #ffffff;
		}

		#positionDisplay {
			position: fixed;
			bottom: 10px;
			left: 10px;
			padding: 10px;
			background: rgba(0, 0, 0, 1);
			border-radius: 5px;
			font-family: Arial, sans-serif;
			font-size: 14px;
			color: #ffffff;
		}
	</style>
</head>

<body>
	<div id="forearmView"></div>

	<div id="positionDisplay">
		Position: x: 0, y: 0, z: 0
	</div>

	<div id="demoStatus">
		Demo Mode: OFF
	</div>

	<div id="keyGuide">
		<strong>Controls:</strong><br>
		Base - A/D<br>
		Upper Arm - W/S<br>
		Forearm - R/F<br>
		Toggle Demo Mode - M
	</div>

	<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/cannon@0.6.2/tools/threejs/CannonDebugRenderer.js"></script>

	<script>
		const demoSpeed = 0.01;
		let base;
		let boxBody;
		let camera;
		let controls;
		let demoMode = false;
		let elbow;
		let forearm;
		let forearmCamera;
		let forearmRenderer;
		let forearmCameraIsActive = true;
		let fullCycleCount = 0;
		let pincerClaw1;
		let pincerClaw2;
		let renderer;
		let scene;
		let shoulder;
		let sphereDot;
		let sphereDotBody;
		let upperArm;
		let world;

		function init() {
			world = new CANNON.World();
			world.gravity.set(0, -9.82, 0);

			setupScene();

			cannonDebugRenderer = new THREE.CannonDebugRenderer(scene, world);

			addPhysicsBox();
			setupCamera();
			setupRenderer();
			addLighting();
			addFloor();
			addRobotArm();
			setupControls();
			initForearmCamera();
			animate();
		}

		function initForearmCamera() {
			const aspect = 16 / 9;
			const fov = 60;
			forearmCamera = new THREE.PerspectiveCamera(fov, aspect, 0.1, 1000);
			forearmRenderer = new THREE.WebGLRenderer({
				antialias: true
			});
			forearmRenderer.setSize(250, 150);
			forearmRenderer.gammaFactor = 2.2;
			forearmRenderer.outputEncoding = THREE.sRGBEncoding;
			forearmRenderer.shadowMap.enabled = true;
			forearmRenderer.shadowMap.type = THREE.PCFSoftShadowMap;
			document.getElementById('forearmView').appendChild(forearmRenderer.domElement);
		}

		function setupScene() {
			scene = new THREE.Scene();
			const gridSize = 10;
			const gridDivisions = 10;
			const gridHelper = new THREE.GridHelper(gridSize, gridDivisions);
			scene.add(gridHelper);
		}

		function setupCamera() {
			camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
			camera.position.set(4, 1, 0);
			camera.lookAt(0, 1, 0);
		}

		function setupRenderer() {
			renderer = new THREE.WebGLRenderer({
				antialias: true
			});
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.gammaFactor = 2.2;
			renderer.outputEncoding = THREE.sRGBEncoding;
			document.body.appendChild(renderer.domElement);
		}

		function addLighting() {
			const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
			directionalLight.position.set(0, 10, 10).normalize();
			directionalLight.castShadow = true;
			scene.add(directionalLight);

			const pointLight = new THREE.PointLight(0xffffff, 1, 100);
			pointLight.position.set(10, 10, 10);
			scene.add(pointLight);

			const ambientLight = new THREE.AmbientLight(0x404040);
			scene.add(ambientLight);
		}

		function addPhysicsBox() {
			const boxGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
			const boxMaterial = new THREE.MeshStandardMaterial({
				color: 0x5865f2
			});
			const boxMesh = new THREE.Mesh(boxGeometry, boxMaterial);
			scene.add(boxMesh);

			const boxShape = new CANNON.Box(new CANNON.Vec3(0.25, 0.25, 0.25));
			boxBody = new CANNON.Body({
				mass: 10,
				restitution: 0.5,
				shape: boxShape,
				position: new CANNON.Vec3(0, 0.25, 1.25)
			});
			world.addBody(boxBody);
			boxMesh.userData.physicsBody = boxBody;
			boxBody.addEventListener('collide', function(e) {
				//console.log('Box collided with', e.body);
			});
		}

		function addRobotArm() {

			const baseMaterial = new THREE.MeshStandardMaterial({
				color: 0x5865f2,
				metalness: 0.5,
				roughness: 0.4
			});

			const material = new THREE.MeshStandardMaterial({
				color: 0xffffff,
				metalness: 0.5,
				roughness: 0.4
			});

			const baseGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.2, 32);
			base = new THREE.Mesh(baseGeometry, baseMaterial);
			base.position.y = 0.1;

			const shoulderGeometry = new THREE.SphereGeometry(0.2, 32, 32);
			shoulder = new THREE.Mesh(shoulderGeometry, baseMaterial);
			shoulder.position.y = 0.1;
			const maxShoulderAngle = 45;
			shoulder.rotation.x = THREE.MathUtils.degToRad(maxShoulderAngle);

			const upperArmGeometry = new THREE.BoxGeometry(0.1, 1, 0.1);
			upperArm = new THREE.Mesh(upperArmGeometry, material);
			upperArm.position.y = 0.5;

			const elbowGeometry = new THREE.CylinderGeometry(0.15, 0.15, 0.15, 32);
			const elbowMaterial = new THREE.MeshStandardMaterial({
				color: 0x5865f2
			});
			elbow = new THREE.Mesh(elbowGeometry, elbowMaterial);
			elbow.position.y = 0.6;
			elbow.rotation.z = Math.PI / 2;
			elbow.castShadow = true;
			elbow.receiveShadow = true;
			const maxElbowAngle = 45;
			elbow.rotation.x = THREE.MathUtils.degToRad(maxElbowAngle);

			const forearmGeometry = new THREE.BoxGeometry(0.1, 0.1, 0.7);
			const forearmMaterial = new THREE.MeshStandardMaterial({
				color: 0xffffff
			});
			forearm = new THREE.Mesh(forearmGeometry, forearmMaterial);
			forearm.position.set(0, 0, 0.4);

			scene.add(base);
			base.add(shoulder);
			shoulder.add(upperArm);
			upperArm.add(elbow);
			elbow.add(forearm);

			const pincerMaterial = new THREE.MeshStandardMaterial({
				color: 0x5865f2
			});
			const pincerBaseGeometry = new THREE.BoxGeometry(0.2, 0.2, 0.05);
			const pincerBase1 = new THREE.Mesh(pincerBaseGeometry, pincerMaterial);
			const pincerBase2 = new THREE.Mesh(pincerBaseGeometry, pincerMaterial);
			const pincerClawGeometry = new THREE.BoxGeometry(0.2, 0.05, 0.2);
			pincerClaw1 = new THREE.Mesh(pincerClawGeometry, pincerMaterial);
			pincerClaw2 = new THREE.Mesh(pincerClawGeometry, pincerMaterial);

			pincerBase1.position.set(0, 0.1, 0.36);
			pincerBase2.position.set(0, -0.1, 0.36);
			pincerBase1.rotation.x = 0;
			pincerBase2.rotation.x = 0;
			pincerBase1.rotation.z = 0;
			pincerBase2.rotation.z = 0;
			forearm.add(pincerBase1);
			forearm.add(pincerBase2);

			pincerClaw1.position.set(0, 0.1, 0.075);
			pincerClaw2.position.set(0, -0.1, 0.075);
			pincerClaw1.rotation.x = 0;
			pincerClaw2.rotation.x = 0;
			pincerClaw1.rotation.z = 0;
			pincerClaw2.rotation.z = 0;
			pincerBase1.add(pincerClaw1);
			pincerBase2.add(pincerClaw2);

			const dotGeometry = new THREE.SphereGeometry(0.05, 32, 32);
			const dotMaterial = new THREE.MeshBasicMaterial({
				color: 0x00ff00
			});
			sphereDot = new THREE.Mesh(dotGeometry, dotMaterial);
			sphereDot.position.set(0, 0, 0.475);
			forearm.add(sphereDot);

			const sphereDotShape = new CANNON.Sphere(0.05);
			sphereDotBody = new CANNON.Body({
				mass: 0,
				restitution: 0.5,
				shape: sphereDotShape,
				position: new CANNON.Vec3(0, 2, 0)
			});
			world.addBody(sphereDotBody);
			forearm.userData.physicsBody = sphereDotBody;
			sphereDotBody.addEventListener('collide', function(e) {
				//console.log('Box collided with', e.body);
			});

		}

		function addFloor() {
			const backgroundGeometry = new THREE.PlaneGeometry(10, 10);
			const backgroundMaterial = new THREE.MeshStandardMaterial({
				color: 0x777777,
				side: THREE.DoubleSide,
			});
			const background = new THREE.Mesh(backgroundGeometry, backgroundMaterial);
			background.rotation.x = -Math.PI / 2;
			background.position.y = -0.01;
			scene.add(background);

			const gridGeometry = new THREE.PlaneGeometry(10, 10, 10, 10);
			const gridMaterial = new THREE.MeshBasicMaterial({
				color: 0x000000,
				side: THREE.DoubleSide,
				transparent: true,
				opacity: 0.5,
				wireframe: true,
			});
			const grid = new THREE.Mesh(gridGeometry, gridMaterial);
			grid.rotation.x = -Math.PI / 2;
			grid.position.y = 0.001;
			scene.add(grid);

			var floorShape = new CANNON.Plane();
			var floorBody = new CANNON.Body({
				mass: 0
			});
			floorBody.addShape(floorShape);
			floorBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
			world.addBody(floorBody);

			const floorVisualGeometry = new THREE.PlaneGeometry(10, 10);
			const floorVisualMaterial = new THREE.MeshBasicMaterial({
				color: 0x00ff00,
				side: THREE.DoubleSide,
				transparent: true,
				opacity: 0.5,
				wireframe: true
			});
			const floorVisual = new THREE.Mesh(floorVisualGeometry, floorVisualMaterial);
			floorVisual.rotation.x = -Math.PI / 2;
			floorVisual.position.y = -0.01;
			scene.add(floorVisual);
		}

		function setupControls() {
			controls = new THREE.OrbitControls(camera, renderer.domElement);
			controls.target.set(0, 1, 0);
			controls.update();
			document.addEventListener("keydown", onDocumentKeyDown, false);
		}

		function animate() {
			requestAnimationFrame(animate);

			if (world) {
				var targetPosition = new CANNON.Vec3(1, 0, 1);
				var forceDirection = targetPosition.vsub(sphereDotBody.position);
				forceDirection.normalize();
				var forceMagnitude = 5;
				var force = forceDirection.scale(forceMagnitude);

				sphereDotBody.applyForce(force, sphereDotBody.position);

				world.step(1 / 60);

				scene.children.forEach(function(child) {
					if (child.userData.physicsBody) {
						child.position.copy(child.userData.physicsBody.position);
						child.quaternion.copy(child.userData.physicsBody.quaternion);
					}
				});

				var worldPosition = new THREE.Vector3();
				sphereDot.getWorldPosition(worldPosition);
				sphereDotBody.position.copy(worldPosition);

				var worldQuaternion = new THREE.Quaternion();
				sphereDot.getWorldQuaternion(worldQuaternion);
				sphereDotBody.quaternion.copy(worldQuaternion);

				cannonDebugRenderer.update();

				renderer.render(scene, camera);

				if (forearmCameraIsActive) {
					forearmRenderer.render(scene, forearmCamera);
				}
			}

			if (sphereDot) {
				const pos = sphereDotBody.position;
				document.getElementById("positionDisplay").innerText = `x: ${pos.x.toFixed(2)}, y: ${pos.y.toFixed(2)}, z: ${pos.z.toFixed(2)}`;
			}

			if (demoMode) {
				automatedMovements();
			}

			if (forearmCamera && sphereDot) {
				var sphereDotPosition = new THREE.Vector3();
				sphereDot.getWorldPosition(sphereDotPosition);
				forearmCamera.position.copy(sphereDotPosition);

				var forearmDirection = new THREE.Vector3(0, 0, -1);
				forearm.getWorldDirection(forearmDirection);
				forearmCamera.lookAt(forearmDirection.add(sphereDotPosition));
				forearmCamera.rotateX(THREE.MathUtils.degToRad(0));
				forearmRenderer.render(scene, forearmCamera);
			}

			renderer.render(scene, camera);
		}

		function clampRotation(currentRotation, minAngle, maxAngle) {
			const minRadians = THREE.MathUtils.degToRad(minAngle);
			const maxRadians = THREE.MathUtils.degToRad(maxAngle);
			return Math.max(minRadians, Math.min(maxRadians, currentRotation));
		}

		let movementStep = 0;

		function automatedMovements() {
			switch (movementStep) {
				case 0:
					rotateBase(1);
					fullCycleCount += demoSpeed;
					if (fullCycleCount >= 2 * Math.PI) {
						fullCycleCount = 0;
						movementStep++;
					}
					movementStep = 0;
					break;
			}
		}

		function rotateBase(direction) {
			const delta = (demoMode ? demoSpeed : 0.05) * direction;
			base.rotation.y += delta;
		}

		function moveShoulder(direction) {
			const delta = (demoMode ? demoSpeed : 0.05) * direction;
			shoulder.rotation.x += delta;
			shoulder.rotation.x = clampRotation(shoulder.rotation.x, 0, 45);
		}

		function moveElbow(direction) {
			const delta = (demoMode ? demoSpeed : 0.05) * direction;
			elbow.rotation.x += delta;
			elbow.rotation.x = clampRotation(elbow.rotation.x, -90, 45);
		}

		function onDocumentKeyDown(event) {
			var keyCode = event.which;

			if (!demoMode) {
				if (keyCode == 65) {
					rotateBase(1);
				} else if (keyCode == 68) {
					rotateBase(-1);
				} else if (keyCode == 87) {
					moveShoulder(-1);
				} else if (keyCode == 83) {
					moveShoulder(1);
				} else if (keyCode == 82) {
					moveElbow(-1);
				} else if (keyCode == 70) {
					moveElbow(1);
				}
			}

			if (keyCode == 77) {
				demoMode = !demoMode;
				document.getElementById("demoStatus").innerText = "Demo Mode: " + (demoMode ? "ON" : "OFF");
			}
		}

		init();
	</script>
</body>

</html>